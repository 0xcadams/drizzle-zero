import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import {Project} from 'ts-morph';
import {afterEach, beforeEach, describe, expect, it, vi} from 'vitest';
import {
  getConfigFromFile,
  getZeroSchemaDefsFromConfig,
} from '../src/cli/config';
import {getGeneratedSchema} from '../src/cli/shared';
import type {DrizzleToZeroSchema} from '../src/relations';

describe('getGeneratedSchema', () => {
  let tsProject: Project;
  const outputFilePath = 'test-output.gen.ts';
  const schemaPath = path.resolve(__dirname, './schemas/one-to-one.zero.ts');

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, '../tsconfig.json'),
      skipAddingFilesFromTsConfig: true,
    });

    tsProject.addSourceFileAtPath(schemaPath);
  });

  afterEach(async () => {
    // Clean up test output file if it exists
    try {
      await fs.unlink(outputFilePath);
    } catch {
      // Ignore error if file doesn't exist
    }
  });

  it('should generate schema from one-to-one.zero.ts', () => {
    // Get the schema type declaration
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate the schema
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                name: {
                  type: 'string',
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Verify the generated schema contains expected content
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');

    expect(generatedSchema).toContain('export type Schema = typeof schema');

    // Check for fields from the one-to-one schema
    expect(generatedSchema).toContain('"id": {');
    expect(generatedSchema).toContain('"name": {');

    // Verify the auto-generated comment header
    expect(generatedSchema).toContain(
      'This file was automatically generated by drizzle-zero',
    );
  });

  it('should handle complex schema properties correctly', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Create a modified schema with null customType to test special handling
    const complexSchema: DrizzleToZeroSchema<any> = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            customTypeJson: {
              type: 'string',
              optional: false,
              customType: null,
            },
          },
        },
      },
      relationships: {},
    };

    // Generate the schema
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: complexSchema,
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for special handling of null customType
    expect(generatedSchema).toContain(
      'null as unknown as ZeroCustomType<typeof zeroSchema, "users", "customTypeJson">',
    );

    expect(generatedSchema).toContain('"customTypeJson": {');

    expect(generatedSchema).toMatchInlineSnapshot(`
      "// This file was automatically generated by drizzle-zero.
      // You should NOT make any changes in this file as it will be overwritten.

      import type { Row } from "@rocicorp/zero";
      import { createBuilder } from "@rocicorp/zero";
      import type { ZeroCustomType } from "drizzle-zero";
      import type { schema as zeroSchema } from "./tests/schemas/one-to-one.zero";

      const usersTable = {
          "name": "users",
          "primaryKey": ["id"],
          "columns": {
              "customTypeJson": {
                  "type": "string",
                  "optional": false,
                  "customType": null as unknown as ZeroCustomType<typeof zeroSchema, "users", "customTypeJson">
              }
          }
      } as const;
      /**
       * The Zero schema object.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export const schema = {
          "tables": {
              "users": usersTable
          },
          "relationships": {}
      } as const;

      /**
       * Represents the Zero schema type.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export type Schema = typeof schema;
      /**
       * Represents a row from the "users" table.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export type User = Row["users"];

      /**
       * Represents the ZQL query builder.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export const zql = createBuilder(schema);
      /**
       * Represents the Zero schema query builder.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export const builder = zql;

      /** Defines the default types for Zero */
      declare module '@rocicorp/zero' { interface DefaultTypes { schema: Schema; } }
      "
    `);
  });

  it('should throw error when export is not found in config file', () => {
    // Try to get non-existent export
    expect(() =>
      getZeroSchemaDefsFromConfig({
        tsProject,
        configPath: schemaPath,
        exportName: 'nonExistentExport',
      }),
    ).toThrow(
      /❌ drizzle-zero: No config type found in the config file - did you export `default` or `schema`\?/,
    );
  });

  it('should throw error when source file is not found', () => {
    // Try to get schema from a non-existent file
    const nonExistentPath = path.resolve(
      __dirname,
      './schemas/does-not-exist.ts',
    );

    expect(() =>
      getZeroSchemaDefsFromConfig({
        tsProject,
        configPath: nonExistentPath,
        exportName: 'schema',
      }),
    ).toThrow(/❌ drizzle-zero: Failed to find type definitions for/);
  });

  it('should handle schema with empty entries correctly', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Create a schema with an empty entry to test handling
    const schemaWithEmptyEntry: DrizzleToZeroSchema<any> = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            id: {
              type: 'number',
              optional: false,
              customType: null,
            },
          },
        },
        emptyTable: {
          name: 'emptyTable',
          primaryKey: ['id'],
          columns: {},
        },
      },
      relationships: {},
    };

    // Generate the schema
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: schemaWithEmptyEntry,
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Verify the empty entry was handled correctly
    expect(generatedSchema).toContain('"emptyTable": emptyTable');
    expect(generatedSchema).toContain('"columns": {}');
  });

  it('should generate schema from drizzle schema source file', () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock('drizzle-zero', () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Mock the drizzle schema source file
    const mockSourceFile = tsProject.createSourceFile(
      'mock-drizzle-schema.ts',
      `
        export const users = {
          id: { type: "serial", primaryKey: true },
          name: { type: "text", notNull: true }
        };
      `,
    );

    // Use a simpler mock schema that avoids type issues for testing
    const mockSchema = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            id: {type: 'integer', optional: false, customType: undefined},
            name: {type: 'string', optional: false, customType: null},
          },
        },
      },
      relationships: {},
    };

    // Generate the schema with drizzle source
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'drizzle-kit',
        zeroSchema: mockSchema as any, // Type assertion to avoid TypeScript errors
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    // Verify the generated schema contains expected content
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
    expect(generatedSchema).toContain('"id": {');
    expect(generatedSchema).toContain('"name": {');

    expect(generatedSchema).toContain(
      'import type * as drizzleSchema from "./mock-drizzle-schema";',
    );
    expect(generatedSchema).toContain(
      'import type { CustomType } from "drizzle-zero";',
    );

    // Check for the type casting
    expect(generatedSchema).toContain('} as const;');
    expect(generatedSchema).toContain('export type Schema = typeof schema;');

    // Check for the type exports
    expect(generatedSchema).toContain('export type User = Row["users"];');

    // Verify null custom type handling with the correct type path
    const customTypeSchema = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            customField: {
              type: 'string',
              optional: false,
              customType: null,
            },
          },
        },
      },
      relationships: {},
    };

    const customTypeGenerated = getGeneratedSchema({
      tsProject,
      result: {
        type: 'drizzle-kit',
        zeroSchema: customTypeSchema as any, // Type assertion to avoid TypeScript errors
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    expect(customTypeGenerated).toContain(
      'null as unknown as CustomType<typeof drizzleSchema, "users", "customField">',
    );

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it('should handle different directory structures for import paths', async () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock('drizzle-zero', () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Create mock files in different directories to test relative path generation
    const nestedDir = 'nested/deep/structure';
    await fs.mkdir(nestedDir, {recursive: true});

    try {
      const mockDrizzleFile = path.join(nestedDir, 'drizzle-schema.ts');
      const mockOutputFile = 'output/schema.gen.ts';

      await fs.mkdir('output', {recursive: true});

      // Create the mock drizzle schema file
      const mockSource = tsProject.createSourceFile(
        mockDrizzleFile,
        `export const table = { id: { type: "serial" } };`,
      );

      // Generate the schema with files in different directories
      const generatedSchema = getGeneratedSchema({
        tsProject,
        result: {
          type: 'drizzle-kit',
          zeroSchema: {
            tables: {
              table: {
                name: 'table',
                primaryKey: ['id'],
                columns: {
                  id: {
                    type: 'number',
                    optional: false,
                    customType: null,
                  },
                },
              },
            },
            relationships: {},
          },
          drizzleSchemaSourceFile: mockSource,
          drizzleCasing: null,
        },
        outputFilePath: mockOutputFile,
      });

      // Verify correct relative import path was generated
      expect(generatedSchema).toContain(
        'import type * as drizzleSchema from "../nested/deep/structure/drizzle-schema";',
      );
    } finally {
      // Clean up created directories
      await fs.rm(nestedDir, {recursive: true, force: true});
      await fs.rm('output', {recursive: true, force: true});
    }

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it('resolves custom types when output file is nested', async () => {
    const drizzleDir = 'drizzle';
    const outputFile = path.join(drizzleDir, 'zero-schema.gen.ts');

    await fs.mkdir(drizzleDir, {recursive: true});

    try {
      const mockSourceFile = tsProject.createSourceFile(
        path.join(drizzleDir, 'schema.ts'),
        `
          import { pgTable, text } from "drizzle-orm/pg-core";

          export const users = pgTable("users", {
            id: text("id").primaryKey(),
            customField: text("custom_field").$type<string>().notNull(),
          });
        `,
      );

      const generatedSchema = getGeneratedSchema({
        tsProject,
        result: {
          type: 'drizzle-kit',
          zeroSchema: {
            tables: {
              users: {
                name: 'users',
                primaryKey: ['id'],
                columns: {
                  customField: {
                    type: 'string',
                    optional: false,
                    customType: null,
                  },
                },
              },
            },
            relationships: {},
          },
          drizzleSchemaSourceFile: mockSourceFile,
          drizzleCasing: null,
        },
        outputFilePath: outputFile,
      });

      expect(generatedSchema).toContain('null as unknown as string');
    } finally {
      await fs.rm(drizzleDir, {recursive: true, force: true});
    }
  });

  it('should add .js file extensions to imports when jsExtensionOverride is "force"', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "force"
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'force',
    });

    // Verify the import statement includes .js extension
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('should add .js file extensions to drizzle-kit imports when jsExtensionOverride is "force"', () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock('drizzle-zero', () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Mock the drizzle schema source file
    const mockSourceFile = tsProject.createSourceFile(
      'mock-drizzle-schema.ts',
      `
        export const users = {
          id: { type: "serial", primaryKey: true },
          name: { type: "text", notNull: true }
        };
      `,
    );

    const mockSchema = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            id: {type: 'integer', optional: false, customType: undefined},
            name: {type: 'string', optional: false, customType: null},
          },
        },
      },
      relationships: {},
    };

    // Generate the schema with jsExtensionOverride set to "force" for drizzle-kit type
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'drizzle-kit',
        zeroSchema: mockSchema as any,
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
      jsExtensionOverride: 'force',
    });

    // Verify the import statement includes .js extension for drizzle schema
    expect(generatedSchema).toContain('from "./mock-drizzle-schema.js";');

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it('should not add .js file extensions to imports when jsExtensionOverride is "none"', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "none"
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'none',
    });

    // Verify the import statement does NOT include .js extension
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero";',
    );
    expect(generatedSchema).not.toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('should not add .js file extensions to drizzle-kit imports when jsExtensionOverride is "none"', () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock('drizzle-zero', () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Mock the drizzle schema source file
    const mockSourceFile = tsProject.createSourceFile(
      'mock-drizzle-schema-none.ts',
      `
        export const users = {
          id: { type: "serial", primaryKey: true },
          name: { type: "text", notNull: true }
        };
      `,
    );

    const mockSchema = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            id: {type: 'integer', optional: false, customType: undefined},
            name: {type: 'string', optional: false, customType: null},
          },
        },
      },
      relationships: {},
    };

    // Generate the schema with jsExtensionOverride set to "none" for drizzle-kit type
    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'drizzle-kit',
        zeroSchema: mockSchema as any,
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
      jsExtensionOverride: 'none',
    });

    // Verify the import statement does NOT include .js extension for drizzle schema
    expect(generatedSchema).toContain('from "./mock-drizzle-schema-none";');
    expect(generatedSchema).not.toContain(
      'from "./mock-drizzle-schema-none.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it('should auto-detect and add .js extensions when jsExtensionOverride is "auto" with Node16 moduleResolution', () => {
    // Create a temporary tsconfig with Node16 moduleResolution
    const tempTsProject = new Project({
      compilerOptions: {
        moduleResolution: 3, // Node16
      },
    });

    // Add the schema file to the temporary project
    tempTsProject.addSourceFileAtPath(schemaPath);

    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject: tempTsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "auto" (default)
    const generatedSchema = getGeneratedSchema({
      tsProject: tempTsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'auto',
    });

    // Verify the import statement includes .js extension due to Node16
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('should auto-detect and add .js extensions when jsExtensionOverride is "auto" with NodeNext moduleResolution', () => {
    // Create a temporary tsconfig with NodeNext moduleResolution
    const tempTsProject = new Project({
      compilerOptions: {
        moduleResolution: 99, // NodeNext
      },
    });

    // Add the schema file to the temporary project
    tempTsProject.addSourceFileAtPath(schemaPath);

    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject: tempTsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "auto" (default)
    const generatedSchema = getGeneratedSchema({
      tsProject: tempTsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'auto',
    });

    // Verify the import statement includes .js extension due to NodeNext
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('logs auto-detection details when debug mode is enabled', () => {
    const tempTsProject = new Project({
      compilerOptions: {
        moduleResolution: 3, // Node16
      },
    });

    tempTsProject.addSourceFileAtPath(schemaPath);

    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject: tempTsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});

    try {
      getGeneratedSchema({
        tsProject: tempTsProject,
        result: {
          type: 'config',
          zeroSchema: {
            tables: {
              users: {
                name: 'users',
                primaryKey: ['id'],
                columns: {
                  id: {
                    type: 'number',
                    optional: false,
                    customType: undefined,
                  },
                },
              },
            },
            relationships: {},
          },
          exportName: 'schema',
          zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
        },
        outputFilePath,
        debug: true,
      });

      expect(logSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          'Auto-detected moduleResolution requires .js extensions',
        ),
      );
    } finally {
      logSpy.mockRestore();
    }
  });

  it('should not add .js extensions when jsExtensionOverride is "auto" with NodeJs moduleResolution', () => {
    // Create a temporary tsconfig with NodeJs moduleResolution
    const tempTsProject = new Project({
      compilerOptions: {
        moduleResolution: 2, // NodeJs
      },
    });

    // Add the schema file to the temporary project
    tempTsProject.addSourceFileAtPath(schemaPath);

    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject: tempTsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "auto" (default)
    const generatedSchema = getGeneratedSchema({
      tsProject: tempTsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'auto',
    });

    // Verify the import statement does NOT include .js extension due to NodeJs
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero";',
    );
    expect(generatedSchema).not.toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('should not add .js extensions when jsExtensionOverride is "auto" with Bundler moduleResolution', () => {
    // Create a temporary tsconfig with Bundler moduleResolution
    const tempTsProject = new Project({
      compilerOptions: {
        moduleResolution: 100, // Bundler
      },
    });

    // Add the schema file to the temporary project
    tempTsProject.addSourceFileAtPath(schemaPath);

    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject: tempTsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    // Generate schema with jsExtensionOverride set to "auto" (default)
    const generatedSchema = getGeneratedSchema({
      tsProject: tempTsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                customField: {
                  type: 'string',
                  optional: false,
                  customType: null,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsExtensionOverride: 'auto',
    });

    // Verify the import statement does NOT include .js extension due to Bundler
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero";',
    );
    expect(generatedSchema).not.toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain('export const schema = {');
    expect(generatedSchema).toContain('"users": usersTable');
  });

  it('should generate builder export with createBuilder from @rocicorp/zero', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
                name: {
                  type: 'string',
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for @rocicorp/zero imports
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );

    // Check for zql export
    expect(generatedSchema).toContain(
      'export const zql = createBuilder(schema);',
    );
  });

  it('should generate table type exports for each table using Row type', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
                name: {
                  type: 'string',
                  optional: false,
                  customType: undefined,
                },
              },
            },
            posts: {
              name: 'posts',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
                title: {
                  type: 'string',
                  optional: false,
                  customType: undefined,
                },
                userId: {
                  type: 'number',
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for table type exports with proper capitalization
    expect(generatedSchema).toContain('export type User = Row["users"];');
    expect(generatedSchema).toContain('export type Post = Row["posts"];');
  });

  it('should handle table names with various casing correctly', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            userProfiles: {
              name: 'userProfiles',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
            blog_posts: {
              name: 'blog_posts',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
            user: {
              name: 'user',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check that capitalization works correctly for different naming conventions
    expect(generatedSchema).toContain(
      'export type UserProfile = Row["userProfiles"];',
    );
    expect(generatedSchema).toContain(
      'export type BlogPost = Row["blog_posts"];',
    );
    expect(generatedSchema).toContain('export type User = Row["user"];');
  });

  it('should include all new features in drizzle-kit type schemas', () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock('drizzle-zero', () => ({
      DrizzleToZeroSchema: class {},
    }));

    const mockSourceFile = tsProject.createSourceFile(
      'mock-drizzle-schema.ts',
      `export const users = { id: { type: "serial", primaryKey: true } };`,
    );

    const mockSchema = {
      tables: {
        users: {
          name: 'users',
          primaryKey: ['id'],
          columns: {
            id: {type: 'integer', optional: false, customType: undefined},
          },
        },
        posts: {
          name: 'posts',
          primaryKey: ['id'],
          columns: {
            id: {type: 'integer', optional: false, customType: undefined},
          },
        },
      },
      relationships: {},
    };

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'drizzle-kit',
        zeroSchema: mockSchema as any,
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    // Check for all the new imports
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );

    // Check for zql export
    expect(generatedSchema).toContain(
      'export const zql = createBuilder(schema);',
    );

    // Check for table type exports
    expect(generatedSchema).toContain('export type User = Row["users"];');
    expect(generatedSchema).toContain('export type Post = Row["posts"];');

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it('should handle empty tables object gracefully', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {},
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Should still include builder export but not Row import when no tables
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'export const zql = createBuilder(schema);',
    );

    // Should not have any table row type exports, but should still have Schema type
    expect(generatedSchema).toContain('export type Schema = typeof schema;');
    expect(generatedSchema).not.toContain("Row['");
  });

  it('should skip generating table row types when skipTypes is true', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      skipTypes: true,
    });

    // Row import and type exports should be omitted
    expect(generatedSchema).not.toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain('Row["users"]');

    // Builder should still be present
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'export const zql = createBuilder(schema);',
    );
  });

  it('should skip generating the builder when skipBuilder is true', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      skipBuilder: true,
    });

    // Builder import and export should be omitted
    expect(generatedSchema).not.toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain('createBuilder(schema);');

    // Row types should still be present
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain('export type User = Row["users"];');
  });

  it('should set enableLegacyMutators to true', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
          enableLegacyMutators: true,
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      enableLegacyMutators: true,
    });

    // Check that enableLegacyMutators is set to true in the generated schema
    expect(generatedSchema).toContain('"enableLegacyMutators": true');
    expect(generatedSchema).not.toContain('"enableLegacyMutators": false');
  });

  it('should set enableLegacyQueries to true', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
          enableLegacyQueries: true,
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      enableLegacyQueries: true,
    });

    // Check that enableLegacyQueries is set to false in the generated schema
    expect(generatedSchema).toContain('"enableLegacyQueries": true');
    expect(generatedSchema).not.toContain('"enableLegacyQueries": false');
  });

  it('should set both enableLegacyMutators and enableLegacyQueries to true when both enable flags are true', () => {
    const zeroSchemaTypeDecl = getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: 'schema',
    });

    const generatedSchema = getGeneratedSchema({
      tsProject,
      result: {
        type: 'config',
        zeroSchema: {
          tables: {
            users: {
              name: 'users',
              primaryKey: ['id'],
              columns: {
                id: {type: 'number', optional: false, customType: undefined},
              },
            },
          },
          relationships: {},
          enableLegacyMutators: true,
          enableLegacyQueries: true,
        },
        exportName: 'schema',
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      enableLegacyMutators: true,
      enableLegacyQueries: true,
    });

    // Check that both flags are set to false in the generated schema
    expect(generatedSchema).toContain('"enableLegacyMutators": true');
    expect(generatedSchema).toContain('"enableLegacyQueries": true');
    expect(generatedSchema).not.toContain('"enableLegacyMutators": false');
    expect(generatedSchema).not.toContain('"enableLegacyQueries": false');
  });
});

describe('drizzle-kit functions', () => {
  let tsProject: Project;
  const schemaPath = path.resolve(__dirname, './schemas/one-to-one.zero.ts');
  const nonExistentPath = 'non-existent-path.ts';

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, '../tsconfig.json'),
    });
  });

  describe('getDrizzleSchemaSourceFile', () => {
    it('should return source file when it exists', async () => {
      // Import the function to test
      const {getDrizzleSchemaSourceFile} =
        await import('../src/cli/drizzle-kit');

      // Call the function with valid path
      const sourceFile = getDrizzleSchemaSourceFile({
        tsProject,
        drizzleSchemaPath: schemaPath,
      });

      // Verify result
      expect(sourceFile).toBeDefined();
      expect(sourceFile.getFilePath()).toContain('one-to-one.zero.ts');
    });

    it('should throw error when source file does not exist', async () => {
      // Import the function to test
      const {getDrizzleSchemaSourceFile} =
        await import('../src/cli/drizzle-kit');

      // Call with invalid path and expect error
      await expect(() =>
        getDrizzleSchemaSourceFile({
          tsProject,
          drizzleSchemaPath: nonExistentPath,
        }),
      ).toThrow(/❌ drizzle-zero: Failed to find type definitions for/);
    });
  });

  describe('getFullDrizzleSchemaFilePath', () => {
    it('should return the provided schema path when it exists', async () => {
      // Import the function to test
      const {getFullDrizzleSchemaFilePath} =
        await import('../src/cli/drizzle-kit');

      // Create a temporary test file
      const tempFilePath = path.resolve(process.cwd(), 'temp-schema.ts');
      await fs.writeFile(tempFilePath, '// test schema file');

      try {
        // Call the function with valid path
        const result = await getFullDrizzleSchemaFilePath({
          drizzleSchemaPath: 'temp-schema.ts',
          drizzleKitConfigPath: undefined,
        });

        // Verify result
        expect(result.drizzleSchemaPath).toBe(tempFilePath);
        expect(result.casing).toBeNull();
      } finally {
        // Clean up temp file
        await fs.unlink(tempFilePath);
      }
    });

    it('should throw when both paths are undefined', async () => {
      // Reset modules
      vi.resetModules();

      // Import the function to test
      const {getFullDrizzleSchemaFilePath} =
        await import('../src/cli/drizzle-kit');

      // Mock process.exit to throw instead of exiting
      const mockExit = vi.spyOn(process, 'exit').mockImplementation((() => {
        const error = new Error('Exit was called');
        error.name = 'MockExit';
        throw error;
      }) as any);
      const mockConsoleError = vi
        .spyOn(console, 'error')
        .mockImplementation(() => {});

      // Call the function with both paths undefined and expect it to throw
      await expect(
        getFullDrizzleSchemaFilePath({
          drizzleSchemaPath: undefined,
          drizzleKitConfigPath: undefined,
        }),
      ).rejects.toThrow('Exit was called');

      // Verify console.error was called with the expected message
      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining(
          '❌ drizzle-zero: could not find Drizzle Kit config file',
        ),
      );

      // Restore mocks
      mockExit.mockRestore();
      mockConsoleError.mockRestore();
      vi.resetModules();
    });
  });

  describe('getDefaultConfig', () => {
    it('should return config with zero schema when schema path is valid', async () => {
      // Reset modules before importing
      vi.resetModules();

      // Create a temporary schema file that exports a valid drizzle schema
      const tempSchemaContent = `
        import { pgTable, serial, text } from 'drizzle-orm/pg-core';

        export const users = pgTable('users', {
          id: serial('id').primaryKey(),
          name: text('name').notNull()
        });

        export default { users };
      `;

      const tempFilePath = path.resolve(
        process.cwd(),
        'temp-drizzle-schema.ts',
      );
      await fs.writeFile(tempFilePath, tempSchemaContent);

      try {
        // Setup mocks before importing the function
        vi.doMock('tsx/esm/api', () => ({
          tsImport: vi.fn().mockImplementation(path => {
            if (path.includes('temp-drizzle-schema.ts')) {
              return {users: {}};
            }
            return {};
          }),
        }));

        vi.doMock('../src/relations', () => ({
          drizzleZeroConfig: vi.fn().mockReturnValue({
            tables: {
              users: {name: 'users', primaryKey: ['id'], columns: {}},
            },
            relationships: {},
          }),
          DrizzleToZeroSchema: class {},
        }));

        // Mock the source file existence check
        vi.doMock('ts-morph', () => {
          const originalModule = vi.importActual('ts-morph');
          return {
            ...originalModule,
            Project: class MockProject {
              getSourceFile() {
                return {
                  getFilePath: () => tempFilePath,
                };
              }
              addSourceFileAtPath() {}
            },
          };
        });

        // Import the function after mocking
        const {getDefaultConfig} = await import('../src/cli/drizzle-kit');

        // Call the function
        const result = await getDefaultConfig({
          drizzleSchemaPath: tempFilePath,
          drizzleKitConfigPath: undefined,
          tsProject: new (await import('ts-morph')).Project(),
        });

        // Verify result structure
        expect(result).toMatchObject({
          type: 'drizzle-kit',
          zeroSchema: {
            tables: {users: {name: 'users'}},
            relationships: {},
          },
        });
        expect(result.drizzleSchemaSourceFile).toBeDefined();
      } finally {
        // Clean up
        await fs.unlink(tempFilePath);
        vi.resetModules();
      }
    });
  });
});

describe('getConfigFromFile', () => {
  let tsProject: Project;

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, '../tsconfig.json'),
    });
  });

  it('should successfully load and parse a valid config file', async () => {
    const configFilePath = path.resolve(
      __dirname,
      '../integration/drizzle-zero.config.ts',
    );

    const result = await getConfigFromFile({
      configFilePath,
      tsProject,
    });

    // Verify the result structure
    expect(result.type).toBe('config');
    expect(result.exportName).toBe('schema');
    expect(result.zeroSchema).toBeDefined();
    expect(result.zeroSchemaTypeDeclarations).toBeDefined();

    // Verify the schema has the expected structure
    expect(result.zeroSchema?.tables).toBeDefined();
    expect(typeof result.zeroSchema?.tables).toBe('object');

    // Verify some expected tables from the integration config
    expect(result.zeroSchema?.tables).toHaveProperty('user');
    expect(result.zeroSchema?.tables).toHaveProperty('message');
  });
});
