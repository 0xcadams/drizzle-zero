import * as fs from "node:fs/promises";
import * as path from "node:path";
import { Project } from "ts-morph";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import {
  getConfigFromFile,
  getZeroSchemaDefsFromConfig,
} from "../src/cli/config";
import { getGeneratedSchema } from "../src/cli/shared";
import type { DrizzleToZeroSchema } from "../src/relations";

describe("getGeneratedSchema", () => {
  let tsProject: Project;
  const outputFilePath = "test-output.gen.ts";
  const schemaPath = path.resolve(__dirname, "./schemas/one-to-one.zero.ts");

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, "../tsconfig.json"),
    });
  });

  afterEach(async () => {
    // Clean up test output file if it exists
    try {
      await fs.unlink(outputFilePath);
    } catch (error) {
      // Ignore error if file doesn't exist
    }
  });

  it("should generate schema from one-to-one.zero.ts", async () => {
    // Get the schema type declaration
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    // Generate the schema
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: {
                  type: "number",
                  optional: false,
                  customType: undefined,
                },
                name: {
                  type: "string",
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Verify the generated schema contains expected content
    expect(generatedSchema).toContain("export const schema = {");
    expect(generatedSchema).toContain('"users": {');

    expect(generatedSchema).toContain("export type Schema = typeof schema");

    // Check for fields from the one-to-one schema
    expect(generatedSchema).toContain('"id": {');
    expect(generatedSchema).toContain('"name": {');

    // Verify the auto-generated comment header
    expect(generatedSchema).toContain(
      "This file was automatically generated by drizzle-zero",
    );
  });

  it("should handle complex schema properties correctly", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    // Create a modified schema with null customType to test special handling
    const complexSchema: DrizzleToZeroSchema<any> = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            customTypeJson: {
              type: "string",
              optional: false,
              customType: null,
            },
          },
        },
      },
      relationships: {},
    };

    // Generate the schema
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: complexSchema,
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for special handling of null customType
    expect(generatedSchema).toContain(
      'null as unknown as ZeroCustomType<typeof zeroSchema, "users", "customTypeJson">',
    );

    expect(generatedSchema).toContain('"customTypeJson": {');

    expect(generatedSchema).toMatchInlineSnapshot(`
      "/* eslint-disable */
      /* tslint:disable */
      // noinspection JSUnusedGlobalSymbols
      // biome-ignore-all
      /*
       * ------------------------------------------------------------
       * ## This file was automatically generated by drizzle-zero. ##
       * ## Any changes you make to this file will be overwritten. ##
       * ##                                                        ##
       * ## Additionally, you should also exclude this file from   ##
       * ## your linter and/or formatter to prevent it from being  ##
       * ## checked or modified.                                   ##
       * ##                                                        ##
       * ## SOURCE: https://github.com/0xcadams/drizzle-zero        ##
       * ------------------------------------------------------------
       */

      import type { Row } from "@rocicorp/zero";
      import { createBuilder } from "@rocicorp/zero";
      import type { ZeroCustomType } from "drizzle-zero";
      import type { schema as zeroSchema } from "./tests/schemas/one-to-one.zero";

      /**
       * The Zero schema object.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export const schema = {
          "tables": {
              "users": {
                  "name": "users",
                  "primaryKey": ["id"],
                  "columns": {
                      "customTypeJson": {
                          "type": "string",
                          "optional": false,
                          "customType": null as unknown as ZeroCustomType<typeof zeroSchema, "users", "customTypeJson">
                      }
                  }
              }
          },
          "relationships": {}
      } as const;

      /**
       * Represents the Zero schema type.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export type Schema = typeof schema;
      /**
       * Represents a row from the "users" table.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export type User = Row<Schema["tables"]["users"]>;

      /**
       * Represents the Zero schema query builder.
       * This type is auto-generated from your Drizzle schema definition.
       */
      export const builder = createBuilder(schema);
      "
    `);
  });

  it("should throw error when export is not found in config file", async () => {
    // Try to get non-existent export
    await expect(
      getZeroSchemaDefsFromConfig({
        tsProject,
        configPath: schemaPath,
        exportName: "nonExistentExport",
      }),
    ).rejects.toThrow(
      /❌ drizzle-zero: No config type found in the config file - did you export `default` or `schema`\?/,
    );
  });

  it("should throw error when source file is not found", async () => {
    // Try to get schema from a non-existent file
    const nonExistentPath = path.resolve(
      __dirname,
      "./schemas/does-not-exist.ts",
    );

    await expect(
      getZeroSchemaDefsFromConfig({
        tsProject,
        configPath: nonExistentPath,
        exportName: "schema",
      }),
    ).rejects.toThrow(/❌ drizzle-zero: Failed to find type definitions for/);
  });

  it("should handle schema with empty entries correctly", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    // Create a schema with an empty entry to test handling
    const schemaWithEmptyEntry: DrizzleToZeroSchema<any> = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            id: {
              type: "number",
              optional: false,
              customType: null,
            },
          },
        },
        emptyTable: {
          name: "emptyTable",
          primaryKey: ["id"],
          columns: {},
        },
      },
      relationships: {},
    };

    // Generate the schema
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: schemaWithEmptyEntry,
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Verify the empty entry was handled correctly
    expect(generatedSchema).toContain('"emptyTable": {');
    expect(generatedSchema).toContain('"columns": {}');
  });

  it("should generate schema from drizzle schema source file", async () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock("drizzle-zero", () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Mock the drizzle schema source file
    const mockSourceFile = tsProject.createSourceFile(
      "mock-drizzle-schema.ts",
      `
        export const users = {
          id: { type: "serial", primaryKey: true },
          name: { type: "text", notNull: true }
        };
      `,
    );

    // Use a simpler mock schema that avoids type issues for testing
    const mockSchema = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            id: { type: "integer", optional: false, customType: undefined },
            name: { type: "string", optional: false, customType: undefined },
          },
        },
      },
      relationships: {},
    };

    // Generate the schema with drizzle source
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "drizzle-kit",
        zeroSchema: mockSchema as any, // Type assertion to avoid TypeScript errors
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    // Verify the generated schema contains expected content
    expect(generatedSchema).toContain("export const schema = {");
    expect(generatedSchema).toContain('"users": {');
    expect(generatedSchema).toContain('"id": {');
    expect(generatedSchema).toContain('"name": {');

    // Verify the import statements for DrizzleZeroTypes and DrizzleToZeroSchema
    expect(generatedSchema).toContain(
      'import type * as drizzleSchema from "./mock-drizzle-schema";',
    );
    expect(generatedSchema).toContain(
      'import type { DrizzleToZeroSchema } from "drizzle-zero";',
    );

    // Check for the type casting
    expect(generatedSchema).toContain("} as const;");
    expect(generatedSchema).toContain("export type Schema = typeof schema;");

    // Check for the type exports
    expect(generatedSchema).toContain(
      'export type User = Row<Schema["tables"]["users"]>;',
    );

    // Verify null custom type handling with the correct type path
    const customTypeSchema = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            customField: {
              type: "string",
              optional: false,
              customType: null,
            },
          },
        },
      },
      relationships: {},
    };

    const customTypeGenerated = await getGeneratedSchema({
      tsProject,
      result: {
        type: "drizzle-kit",
        zeroSchema: customTypeSchema as any, // Type assertion to avoid TypeScript errors
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    expect(customTypeGenerated).toContain(
      'null as unknown as ZeroCustomType<ZeroSchema, "users", "customField">',
    );

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it("should handle different directory structures for import paths", async () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock("drizzle-zero", () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Create mock files in different directories to test relative path generation
    const nestedDir = "nested/deep/structure";
    await fs.mkdir(nestedDir, { recursive: true });

    try {
      const mockDrizzleFile = path.join(nestedDir, "drizzle-schema.ts");
      const mockOutputFile = "output/schema.gen.ts";

      await fs.mkdir("output", { recursive: true });

      // Create the mock drizzle schema file
      const mockSource = tsProject.createSourceFile(
        mockDrizzleFile,
        `export const table = { id: { type: "serial" } };`,
      );

      // Generate the schema with files in different directories
      const generatedSchema = await getGeneratedSchema({
        tsProject,
        result: {
          type: "drizzle-kit",
          zeroSchema: {
            tables: {
              table: {
                name: "table",
                primaryKey: ["id"],
                columns: {
                  id: {
                    type: "number",
                    optional: false,
                    customType: undefined,
                  },
                },
              },
            },
            relationships: {},
          },
          drizzleSchemaSourceFile: mockSource,
          drizzleCasing: null,
        },
        outputFilePath: mockOutputFile,
      });

      // Verify correct relative import path was generated
      expect(generatedSchema).toContain(
        'import type * as drizzleSchema from "../nested/deep/structure/drizzle-schema";',
      );
    } finally {
      // Clean up created directories
      await fs.rm(nestedDir, { recursive: true, force: true });
      await fs.rm("output", { recursive: true, force: true });
    }

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it("should add .js file extensions to imports when jsFileExtension is true", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    // Generate schema with jsFileExtension enabled
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: {
                  type: "number",
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      jsFileExtension: true,
    });

    // Verify the import statement includes .js extension
    expect(generatedSchema).toContain(
      'from "./tests/schemas/one-to-one.zero.js";',
    );

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain("export const schema = {");
    expect(generatedSchema).toContain('"users": {');
  });

  it("should add .js file extensions to drizzle-kit imports when jsFileExtension is true", async () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock("drizzle-zero", () => ({
      DrizzleToZeroSchema: class {},
    }));

    // Mock the drizzle schema source file
    const mockSourceFile = tsProject.createSourceFile(
      "mock-drizzle-schema.ts",
      `
        export const users = {
          id: { type: "serial", primaryKey: true },
          name: { type: "text", notNull: true }
        };
      `,
    );

    const mockSchema = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            id: { type: "integer", optional: false, customType: undefined },
            name: { type: "string", optional: false, customType: undefined },
          },
        },
      },
      relationships: {},
    };

    // Generate the schema with jsFileExtension enabled for drizzle-kit type
    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "drizzle-kit",
        zeroSchema: mockSchema as any,
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
      jsFileExtension: true,
    });

    // Verify the import statement includes .js extension for drizzle schema
    expect(generatedSchema).toContain('from "./mock-drizzle-schema.js";');

    // Verify the rest of the schema is still generated correctly
    expect(generatedSchema).toContain("export const schema = {");
    expect(generatedSchema).toContain('"users": {');

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it("should generate builder export with createBuilder from @rocicorp/zero", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: {
                  type: "number",
                  optional: false,
                  customType: undefined,
                },
                name: {
                  type: "string",
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for @rocicorp/zero imports
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );

    // Check for builder export
    expect(generatedSchema).toContain(
      "export const builder = createBuilder(schema);",
    );

    // Check for builder JSDoc
    expect(generatedSchema).toContain(
      "Represents the Zero schema query builder",
    );
  });

  it("should generate table type exports for each table using Row type", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
                name: {
                  type: "string",
                  optional: false,
                  customType: undefined,
                },
              },
            },
            posts: {
              name: "posts",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
                title: {
                  type: "string",
                  optional: false,
                  customType: undefined,
                },
                userId: {
                  type: "number",
                  optional: false,
                  customType: undefined,
                },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check for table type exports with proper capitalization
    expect(generatedSchema).toContain(
      'export type User = Row<Schema["tables"]["users"]>;',
    );
    expect(generatedSchema).toContain(
      'export type Post = Row<Schema["tables"]["posts"]>;',
    );

    // Check for JSDoc comments on table types
    expect(generatedSchema).toContain(
      'Represents a row from the "users" table',
    );
    expect(generatedSchema).toContain(
      'Represents a row from the "posts" table',
    );
  });

  it("should handle table names with various casing correctly", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            userProfiles: {
              name: "userProfiles",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
              },
            },
            blog_posts: {
              name: "blog_posts",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
              },
            },
            user: {
              name: "user",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Check that capitalization works correctly for different naming conventions
    expect(generatedSchema).toContain(
      'export type UserProfile = Row<Schema["tables"]["userProfiles"]>;',
    );
    expect(generatedSchema).toContain(
      'export type BlogPost = Row<Schema["tables"]["blog_posts"]>;',
    );
    expect(generatedSchema).toContain(
      'export type User = Row<Schema["tables"]["user"]>;',
    );
  });

  it("should include all new features in drizzle-kit type schemas", async () => {
    // Mock the DrizzleToZeroSchema type
    vi.mock("drizzle-zero", () => ({
      DrizzleToZeroSchema: class {},
    }));

    const mockSourceFile = tsProject.createSourceFile(
      "mock-drizzle-schema.ts",
      `export const users = { id: { type: "serial", primaryKey: true } };`,
    );

    const mockSchema = {
      tables: {
        users: {
          name: "users",
          primaryKey: ["id"],
          columns: {
            id: { type: "integer", optional: false, customType: undefined },
          },
        },
        posts: {
          name: "posts",
          primaryKey: ["id"],
          columns: {
            id: { type: "integer", optional: false, customType: undefined },
          },
        },
      },
      relationships: {},
    };

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "drizzle-kit",
        zeroSchema: mockSchema as any,
        drizzleSchemaSourceFile: mockSourceFile,
        drizzleCasing: null,
      },
      outputFilePath,
    });

    // Check for all the new imports
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );

    // Check for builder export
    expect(generatedSchema).toContain(
      "export const builder = createBuilder(schema);",
    );

    // Check for table type exports
    expect(generatedSchema).toContain(
      'export type User = Row<Schema["tables"]["users"]>;',
    );
    expect(generatedSchema).toContain(
      'export type Post = Row<Schema["tables"]["posts"]>;',
    );

    // Reset the mock after the test
    vi.restoreAllMocks();
  });

  it("should handle empty tables object gracefully", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {},
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
    });

    // Should still include builder export but not Row import when no tables
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      "export const builder = createBuilder(schema);",
    );

    // Should not have any table row type exports, but should still have Schema type
    expect(generatedSchema).toContain("export type Schema = typeof schema;");
    expect(generatedSchema).not.toContain('Row<Schema["tables"]');
  });

  it("should skip generating table row types when skipTypes is true", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      skipTypes: true,
    });

    // Row import and type exports should be omitted
    expect(generatedSchema).not.toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain('Row<Schema["tables"]["users"]>');

    // Builder should still be present
    expect(generatedSchema).toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      "export const builder = createBuilder(schema);",
    );
  });

  it("should skip generating the builder when skipBuilder is true", async () => {
    const zeroSchemaTypeDecl = await getZeroSchemaDefsFromConfig({
      tsProject,
      configPath: schemaPath,
      exportName: "schema",
    });

    const generatedSchema = await getGeneratedSchema({
      tsProject,
      result: {
        type: "config",
        zeroSchema: {
          tables: {
            users: {
              name: "users",
              primaryKey: ["id"],
              columns: {
                id: { type: "number", optional: false, customType: undefined },
              },
            },
          },
          relationships: {},
        },
        exportName: "schema",
        zeroSchemaTypeDeclarations: zeroSchemaTypeDecl,
      },
      outputFilePath,
      skipBuilder: true,
    });

    // Builder import and export should be omitted
    expect(generatedSchema).not.toContain(
      'import { createBuilder } from "@rocicorp/zero";',
    );
    expect(generatedSchema).not.toContain(
      "export const builder = createBuilder(schema);",
    );

    // Row types should still be present
    expect(generatedSchema).toContain(
      'import type { Row } from "@rocicorp/zero";',
    );
    expect(generatedSchema).toContain(
      'export type User = Row<Schema["tables"]["users"]>;',
    );
  });
});

describe("drizzle-kit functions", () => {
  let tsProject: Project;
  const schemaPath = path.resolve(__dirname, "./schemas/one-to-one.zero.ts");
  const nonExistentPath = "non-existent-path.ts";

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, "../tsconfig.json"),
    });
  });

  describe("getDrizzleSchemaSourceFile", () => {
    it("should return source file when it exists", async () => {
      // Import the function to test
      const { getDrizzleSchemaSourceFile } = await import(
        "../src/cli/drizzle-kit"
      );

      // Call the function with valid path
      const sourceFile = await getDrizzleSchemaSourceFile({
        tsProject,
        drizzleSchemaPath: schemaPath,
      });

      // Verify result
      expect(sourceFile).toBeDefined();
      expect(sourceFile.getFilePath()).toContain("one-to-one.zero.ts");
    });

    it("should throw error when source file does not exist", async () => {
      // Import the function to test
      const { getDrizzleSchemaSourceFile } = await import(
        "../src/cli/drizzle-kit"
      );

      // Call with invalid path and expect error
      await expect(
        getDrizzleSchemaSourceFile({
          tsProject,
          drizzleSchemaPath: nonExistentPath,
        }),
      ).rejects.toThrow(/❌ drizzle-zero: Failed to find type definitions for/);
    });
  });

  describe("getFullDrizzleSchemaFilePath", () => {
    it("should return the provided schema path when it exists", async () => {
      // Import the function to test
      const { getFullDrizzleSchemaFilePath } = await import(
        "../src/cli/drizzle-kit"
      );

      // Create a temporary test file
      const tempFilePath = path.resolve(process.cwd(), "temp-schema.ts");
      await fs.writeFile(tempFilePath, "// test schema file");

      try {
        // Call the function with valid path
        const result = await getFullDrizzleSchemaFilePath({
          drizzleSchemaPath: "temp-schema.ts",
          drizzleKitConfigPath: undefined,
        });

        // Verify result
        expect(result.drizzleSchemaPath).toBe(tempFilePath);
        expect(result.casing).toBeNull();
      } finally {
        // Clean up temp file
        await fs.unlink(tempFilePath);
      }
    });

    it("should throw when both paths are undefined", async () => {
      // Reset modules
      vi.resetModules();

      // Import the function to test
      const { getFullDrizzleSchemaFilePath } = await import(
        "../src/cli/drizzle-kit"
      );

      // Mock process.exit to throw instead of exiting
      const mockExit = vi.spyOn(process, "exit").mockImplementation((() => {
        const error = new Error("Exit was called");
        error.name = "MockExit";
        throw error;
      }) as any);
      const mockConsoleError = vi
        .spyOn(console, "error")
        .mockImplementation(() => {});

      // Call the function with both paths undefined and expect it to throw
      await expect(
        getFullDrizzleSchemaFilePath({
          drizzleSchemaPath: undefined,
          drizzleKitConfigPath: undefined,
        }),
      ).rejects.toThrow("Exit was called");

      // Verify console.error was called with the expected message
      expect(mockConsoleError).toHaveBeenCalledWith(
        expect.stringContaining(
          "❌ drizzle-zero: could not find Drizzle Kit config file",
        ),
      );

      // Restore mocks
      mockExit.mockRestore();
      mockConsoleError.mockRestore();
      vi.resetModules();
    });
  });

  describe("getDefaultConfig", () => {
    it("should return config with zero schema when schema path is valid", async () => {
      // Reset modules before importing
      vi.resetModules();

      // Create a temporary schema file that exports a valid drizzle schema
      const tempSchemaContent = `
        import { pgTable, serial, text } from 'drizzle-orm/pg-core';

        export const users = pgTable('users', {
          id: serial('id').primaryKey(),
          name: text('name').notNull()
        });

        export default { users };
      `;

      const tempFilePath = path.resolve(
        process.cwd(),
        "temp-drizzle-schema.ts",
      );
      await fs.writeFile(tempFilePath, tempSchemaContent);

      try {
        // Setup mocks before importing the function
        vi.doMock("tsx/esm/api", () => ({
          tsImport: vi.fn().mockImplementation(async (path) => {
            if (path.includes("temp-drizzle-schema.ts")) {
              return { users: {} };
            }
            return {};
          }),
        }));

        vi.doMock("../src/relations", () => ({
          drizzleZeroConfig: vi.fn().mockReturnValue({
            tables: {
              users: { name: "users", primaryKey: ["id"], columns: {} },
            },
            relationships: {},
          }),
          DrizzleToZeroSchema: class {},
        }));

        // Mock the source file existence check
        vi.doMock("ts-morph", () => {
          const originalModule = vi.importActual("ts-morph");
          return {
            ...originalModule,
            Project: class MockProject {
              getSourceFile() {
                return {
                  getFilePath: () => tempFilePath,
                };
              }
              addSourceFileAtPath() {}
            },
          };
        });

        // Import the function after mocking
        const { getDefaultConfig } = await import("../src/cli/drizzle-kit");

        // Call the function
        const result = await getDefaultConfig({
          drizzleSchemaPath: tempFilePath,
          drizzleKitConfigPath: undefined,
          tsProject: new (await import("ts-morph")).Project(),
        });

        // Verify result structure
        expect(result).toMatchObject({
          type: "drizzle-kit",
          zeroSchema: {
            tables: { users: { name: "users" } },
            relationships: {},
          },
        });
        expect(result.drizzleSchemaSourceFile).toBeDefined();
      } finally {
        // Clean up
        await fs.unlink(tempFilePath);
        vi.resetModules();
      }
    });
  });
});

describe("getConfigFromFile", () => {
  let tsProject: Project;

  beforeEach(() => {
    tsProject = new Project({
      tsConfigFilePath: path.resolve(__dirname, "../tsconfig.json"),
    });
  });

  it("should successfully load and parse a valid config file", async () => {
    const configFilePath = path.resolve(
      __dirname,
      "../integration/drizzle-zero.config.ts",
    );

    const result = await getConfigFromFile({
      configFilePath,
      tsProject,
    });

    // Verify the result structure
    expect(result.type).toBe("config");
    expect(result.exportName).toBe("schema");
    expect(result.zeroSchema).toBeDefined();
    expect(result.zeroSchemaTypeDeclarations).toBeDefined();

    // Verify the schema has the expected structure
    expect(result.zeroSchema?.tables).toBeDefined();
    expect(typeof result.zeroSchema?.tables).toBe("object");

    // Verify some expected tables from the integration config
    expect(result.zeroSchema?.tables).toHaveProperty("user");
    expect(result.zeroSchema?.tables).toHaveProperty("message");

    expect(result.zeroSchema).toMatchInlineSnapshot(`
      {
        "enableLegacyMutators": undefined,
        "enableLegacyQueries": undefined,
        "relationships": {
          "filters": {
            "children": [
              {
                "cardinality": "many",
                "destField": [
                  "parentId",
                ],
                "destSchema": "filters",
                "sourceField": [
                  "id",
                ],
              },
            ],
            "parent": [
              {
                "cardinality": "one",
                "destField": [
                  "id",
                ],
                "destSchema": "filters",
                "sourceField": [
                  "parentId",
                ],
              },
            ],
          },
          "medium": {
            "messages": [
              {
                "cardinality": "many",
                "destField": [
                  "mediumId",
                ],
                "destSchema": "message",
                "sourceField": [
                  "id",
                ],
              },
            ],
          },
          "message": {
            "medium": [
              {
                "cardinality": "one",
                "destField": [
                  "id",
                ],
                "destSchema": "medium",
                "sourceField": [
                  "mediumId",
                ],
              },
            ],
            "sender": [
              {
                "cardinality": "one",
                "destField": [
                  "id",
                ],
                "destSchema": "user",
                "sourceField": [
                  "senderId",
                ],
              },
            ],
          },
          "user": {
            "friends": [
              {
                "cardinality": "many",
                "destField": [
                  "requestingId",
                ],
                "destSchema": "friendship",
                "sourceField": [
                  "id",
                ],
              },
              {
                "cardinality": "many",
                "destField": [
                  "id",
                ],
                "destSchema": "user",
                "sourceField": [
                  "acceptingId",
                ],
              },
            ],
            "mediums": [
              {
                "cardinality": "many",
                "destField": [
                  "senderId",
                ],
                "destSchema": "message",
                "sourceField": [
                  "id",
                ],
              },
              {
                "cardinality": "many",
                "destField": [
                  "id",
                ],
                "destSchema": "medium",
                "sourceField": [
                  "mediumId",
                ],
              },
            ],
            "messages": [
              {
                "cardinality": "many",
                "destField": [
                  "senderId",
                ],
                "destSchema": "message",
                "sourceField": [
                  "id",
                ],
              },
            ],
          },
        },
        "tables": {
          "allTypes": {
            "columns": {
              "bigSerialField": {
                "customType": null,
                "optional": true,
                "serverName": "bigserial",
                "type": "number",
              },
              "bigintField": {
                "customType": null,
                "optional": false,
                "serverName": "bigint",
                "type": "number",
              },
              "bigintNumberField": {
                "customType": null,
                "optional": false,
                "serverName": "bigint_number",
                "type": "number",
              },
              "booleanField": {
                "customType": null,
                "optional": false,
                "serverName": "boolean",
                "type": "boolean",
              },
              "charField": {
                "customType": null,
                "optional": false,
                "serverName": "char",
                "type": "string",
              },
              "createdAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
              "dateField": {
                "customType": null,
                "optional": false,
                "serverName": "date",
                "type": "number",
              },
              "decimalField": {
                "customType": null,
                "optional": false,
                "serverName": "decimal",
                "type": "number",
              },
              "doublePrecisionField": {
                "customType": null,
                "optional": false,
                "serverName": "double_precision",
                "type": "number",
              },
              "id": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "integerField": {
                "customType": null,
                "optional": false,
                "serverName": "integer",
                "type": "number",
              },
              "jsonField": {
                "customType": null,
                "optional": false,
                "serverName": "json",
                "type": "json",
              },
              "jsonbField": {
                "customType": null,
                "optional": false,
                "serverName": "jsonb",
                "type": "json",
              },
              "numericField": {
                "customType": null,
                "optional": false,
                "serverName": "numeric",
                "type": "number",
              },
              "optionalBigint": {
                "customType": null,
                "optional": true,
                "serverName": "optional_bigint",
                "type": "number",
              },
              "optionalBoolean": {
                "customType": null,
                "optional": true,
                "serverName": "optional_boolean",
                "type": "boolean",
              },
              "optionalDoublePrecision": {
                "customType": null,
                "optional": true,
                "serverName": "optional_double_precision",
                "type": "number",
              },
              "optionalEnum": {
                "customType": null,
                "optional": true,
                "serverName": "optional_enum",
                "type": "string",
              },
              "optionalInteger": {
                "customType": null,
                "optional": true,
                "serverName": "optional_integer",
                "type": "number",
              },
              "optionalJson": {
                "customType": null,
                "optional": true,
                "serverName": "optional_json",
                "type": "json",
              },
              "optionalNumeric": {
                "customType": null,
                "optional": true,
                "serverName": "optional_numeric",
                "type": "number",
              },
              "optionalReal": {
                "customType": null,
                "optional": true,
                "serverName": "optional_real",
                "type": "number",
              },
              "optionalSmallint": {
                "customType": null,
                "optional": true,
                "serverName": "optional_smallint",
                "type": "number",
              },
              "optionalText": {
                "customType": null,
                "optional": true,
                "serverName": "optional_text",
                "type": "string",
              },
              "optionalTimestamp": {
                "customType": null,
                "optional": true,
                "serverName": "optional_timestamp",
                "type": "number",
              },
              "optionalUuid": {
                "customType": null,
                "optional": true,
                "serverName": "optional_uuid",
                "type": "string",
              },
              "optionalVarchar": {
                "customType": null,
                "optional": true,
                "serverName": "optional_varchar",
                "type": "string",
              },
              "realField": {
                "customType": null,
                "optional": false,
                "serverName": "real",
                "type": "number",
              },
              "serialField": {
                "customType": null,
                "optional": true,
                "serverName": "serial",
                "type": "number",
              },
              "smallSerialField": {
                "customType": null,
                "optional": true,
                "serverName": "smallserial",
                "type": "number",
              },
              "smallintField": {
                "customType": null,
                "optional": false,
                "serverName": "smallint",
                "type": "number",
              },
              "status": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "textField": {
                "customType": null,
                "optional": false,
                "serverName": "text",
                "type": "string",
              },
              "timestampField": {
                "customType": null,
                "optional": false,
                "serverName": "timestamp",
                "type": "number",
              },
              "timestampModeDate": {
                "customType": null,
                "optional": false,
                "serverName": "timestamp_mode_date",
                "type": "number",
              },
              "timestampModeString": {
                "customType": null,
                "optional": false,
                "serverName": "timestamp_mode_string",
                "type": "number",
              },
              "timestampTzField": {
                "customType": null,
                "optional": false,
                "serverName": "timestamp_tz",
                "type": "number",
              },
              "typedJsonField": {
                "customType": null,
                "optional": false,
                "serverName": "typed_json",
                "type": "json",
              },
              "updatedAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
              "uuidField": {
                "customType": null,
                "optional": false,
                "serverName": "uuid",
                "type": "string",
              },
              "varcharField": {
                "customType": null,
                "optional": false,
                "serverName": "varchar",
                "type": "string",
              },
            },
            "name": "allTypes",
            "primaryKey": [
              "id",
            ],
            "serverName": "all_types",
          },
          "filters": {
            "columns": {
              "id": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "name": {
                "customType": null,
                "optional": true,
                "type": "string",
              },
              "parentId": {
                "customType": null,
                "optional": true,
                "serverName": "parent_id",
                "type": "string",
              },
            },
            "name": "filters",
            "primaryKey": [
              "id",
            ],
          },
          "friendship": {
            "columns": {
              "accepted": {
                "customType": null,
                "optional": false,
                "type": "boolean",
              },
              "acceptingId": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "requestingId": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
            },
            "name": "friendship",
            "primaryKey": [
              "requestingId",
              "acceptingId",
            ],
          },
          "medium": {
            "columns": {
              "createdAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
              "id": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "name": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "updatedAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
            },
            "name": "medium",
            "primaryKey": [
              "id",
            ],
          },
          "message": {
            "columns": {
              "body": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "createdAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
              "id": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "mediumId": {
                "customType": null,
                "optional": true,
                "type": "string",
              },
              "metadata": {
                "customType": null,
                "optional": false,
                "type": "json",
              },
              "senderId": {
                "customType": null,
                "optional": true,
                "type": "string",
              },
              "updatedAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
            },
            "name": "message",
            "primaryKey": [
              "id",
            ],
          },
          "user": {
            "columns": {
              "createdAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
              "customInterfaceJson": {
                "customType": null,
                "optional": false,
                "serverName": "custom_interface_json",
                "type": "json",
              },
              "customTypeJson": {
                "customType": null,
                "optional": false,
                "serverName": "custom_type_json",
                "type": "json",
              },
              "email": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "id": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "name": {
                "customType": null,
                "optional": false,
                "type": "string",
              },
              "partner": {
                "customType": null,
                "optional": false,
                "type": "boolean",
              },
              "testExportedType": {
                "customType": null,
                "optional": false,
                "serverName": "test_exported_type",
                "type": "json",
              },
              "testInterface": {
                "customType": null,
                "optional": false,
                "serverName": "test_interface",
                "type": "json",
              },
              "testType": {
                "customType": null,
                "optional": false,
                "serverName": "test_type",
                "type": "json",
              },
              "updatedAt": {
                "customType": null,
                "optional": true,
                "type": "number",
              },
            },
            "name": "user",
            "primaryKey": [
              "id",
            ],
          },
        },
      }
    `);
  });
});
